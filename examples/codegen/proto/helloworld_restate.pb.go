// Code generated by protoc-gen-go-restate. DO NOT EDIT.
// versions:
// - protoc-gen-go-restate v0.1
// - protoc             (unknown)
// source: proto/helloworld.proto

package proto

import (
	context "context"
	fmt "fmt"
	sdk_go "github.com/restatedev/sdk-go"
	encoding "github.com/restatedev/sdk-go/encoding"
	ingress "github.com/restatedev/sdk-go/ingress"
)

// GreeterClient is the client API for helloworld.Greeter service.
type GreeterClient interface {
	SayHello(opts ...sdk_go.ClientOption) sdk_go.Client[*HelloRequest, *HelloResponse]
}

type greeterClient struct {
	ctx     sdk_go.Context
	options []sdk_go.ClientOption
}

func NewGreeterClient(ctx sdk_go.Context, opts ...sdk_go.ClientOption) GreeterClient {
	cOpts := append([]sdk_go.ClientOption{sdk_go.WithProtoJSON}, opts...)
	return &greeterClient{
		ctx,
		cOpts,
	}
}
func (c *greeterClient) SayHello(opts ...sdk_go.ClientOption) sdk_go.Client[*HelloRequest, *HelloResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*HelloRequest](sdk_go.Service[*HelloResponse](c.ctx, "helloworld.Greeter", "SayHello", cOpts...))
}

// GreeterIngressClient is the ingress client API for helloworld.Greeter service.
//
// This client is used to call the service from outside of a Restate context.
type GreeterIngressClient interface {
	SayHello() ingress.Requester[*HelloRequest, *HelloResponse]
}

type greeterIngressClient struct {
	client      *ingress.Client
	serviceName string
}

func NewGreeterIngressClient(client *ingress.Client) GreeterIngressClient {
	return &greeterIngressClient{
		client,
		"helloworld.Greeter",
	}
}

func (c *greeterIngressClient) SayHello() ingress.Requester[*HelloRequest, *HelloResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*HelloRequest, *HelloResponse](c.client, c.serviceName, "SayHello", nil, &codec)
}

// GreeterServer is the server API for helloworld.Greeter service.
// All implementations should embed UnimplementedGreeterServer
// for forward compatibility.
type GreeterServer interface {
	SayHello(ctx sdk_go.Context, req *HelloRequest) (*HelloResponse, error)
}

// UnimplementedGreeterServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGreeterServer struct{}

func (UnimplementedGreeterServer) SayHello(ctx sdk_go.Context, req *HelloRequest) (*HelloResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method SayHello not implemented"), 501)
}
func (UnimplementedGreeterServer) testEmbeddedByValue() {}

// UnsafeGreeterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GreeterServer will
// result in compilation errors.
type UnsafeGreeterServer interface {
	mustEmbedUnimplementedGreeterServer()
}

func NewGreeterServer(srv GreeterServer, opts ...sdk_go.ServiceDefinitionOption) sdk_go.ServiceDefinition {
	// If the following call panics, it indicates UnimplementedGreeterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	sOpts := append([]sdk_go.ServiceDefinitionOption{sdk_go.WithProtoJSON}, opts...)
	router := sdk_go.NewService("helloworld.Greeter", sOpts...)
	router = router.Handler("SayHello", sdk_go.NewServiceHandler(srv.SayHello))
	return router
}

// CounterClient is the client API for helloworld.Counter service.
type CounterClient interface {
	// Mutate the value
	Add(opts ...sdk_go.ClientOption) sdk_go.Client[*AddRequest, *GetResponse]
	// Get the current value
	Get(opts ...sdk_go.ClientOption) sdk_go.Client[*GetRequest, *GetResponse]
	// Internal method to store an awakeable ID for the Watch method
	AddWatcher(opts ...sdk_go.ClientOption) sdk_go.Client[*AddWatcherRequest, *AddWatcherResponse]
	// Wait for the counter to change and then return the new value
	Watch(opts ...sdk_go.ClientOption) sdk_go.Client[*WatchRequest, *GetResponse]
}

type counterClient struct {
	ctx     sdk_go.Context
	key     string
	options []sdk_go.ClientOption
}

func NewCounterClient(ctx sdk_go.Context, key string, opts ...sdk_go.ClientOption) CounterClient {
	cOpts := append([]sdk_go.ClientOption{sdk_go.WithProtoJSON}, opts...)
	return &counterClient{
		ctx,
		key,
		cOpts,
	}
}
func (c *counterClient) Add(opts ...sdk_go.ClientOption) sdk_go.Client[*AddRequest, *GetResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*AddRequest](sdk_go.Object[*GetResponse](c.ctx, "helloworld.Counter", c.key, "Add", cOpts...))
}

func (c *counterClient) Get(opts ...sdk_go.ClientOption) sdk_go.Client[*GetRequest, *GetResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*GetRequest](sdk_go.Object[*GetResponse](c.ctx, "helloworld.Counter", c.key, "Get", cOpts...))
}

func (c *counterClient) AddWatcher(opts ...sdk_go.ClientOption) sdk_go.Client[*AddWatcherRequest, *AddWatcherResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*AddWatcherRequest](sdk_go.Object[*AddWatcherResponse](c.ctx, "helloworld.Counter", c.key, "AddWatcher", cOpts...))
}

func (c *counterClient) Watch(opts ...sdk_go.ClientOption) sdk_go.Client[*WatchRequest, *GetResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*WatchRequest](sdk_go.Object[*GetResponse](c.ctx, "helloworld.Counter", c.key, "Watch", cOpts...))
}

// CounterIngressClient is the ingress client API for helloworld.Counter service.
//
// This client is used to call the service from outside of a Restate context.
type CounterIngressClient interface {
	// Mutate the value
	Add() ingress.Requester[*AddRequest, *GetResponse]
	// Get the current value
	Get() ingress.Requester[*GetRequest, *GetResponse]
	// Internal method to store an awakeable ID for the Watch method
	AddWatcher() ingress.Requester[*AddWatcherRequest, *AddWatcherResponse]
	// Wait for the counter to change and then return the new value
	Watch() ingress.Requester[*WatchRequest, *GetResponse]
}

type counterIngressClient struct {
	client      *ingress.Client
	serviceName string
	key         string
}

func NewCounterIngressClient(client *ingress.Client, key string) CounterIngressClient {
	return &counterIngressClient{
		client,
		"helloworld.Counter",
		key,
	}
}

func (c *counterIngressClient) Add() ingress.Requester[*AddRequest, *GetResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*AddRequest, *GetResponse](c.client, c.serviceName, "Add", &c.key, &codec)
}

func (c *counterIngressClient) Get() ingress.Requester[*GetRequest, *GetResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*GetRequest, *GetResponse](c.client, c.serviceName, "Get", &c.key, &codec)
}

func (c *counterIngressClient) AddWatcher() ingress.Requester[*AddWatcherRequest, *AddWatcherResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*AddWatcherRequest, *AddWatcherResponse](c.client, c.serviceName, "AddWatcher", &c.key, &codec)
}

func (c *counterIngressClient) Watch() ingress.Requester[*WatchRequest, *GetResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*WatchRequest, *GetResponse](c.client, c.serviceName, "Watch", &c.key, &codec)
}

// CounterServer is the server API for helloworld.Counter service.
// All implementations should embed UnimplementedCounterServer
// for forward compatibility.
type CounterServer interface {
	// Mutate the value
	Add(ctx sdk_go.ObjectContext, req *AddRequest) (*GetResponse, error)
	// Get the current value
	Get(ctx sdk_go.ObjectSharedContext, req *GetRequest) (*GetResponse, error)
	// Internal method to store an awakeable ID for the Watch method
	AddWatcher(ctx sdk_go.ObjectContext, req *AddWatcherRequest) (*AddWatcherResponse, error)
	// Wait for the counter to change and then return the new value
	Watch(ctx sdk_go.ObjectSharedContext, req *WatchRequest) (*GetResponse, error)
}

// UnimplementedCounterServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCounterServer struct{}

func (UnimplementedCounterServer) Add(ctx sdk_go.ObjectContext, req *AddRequest) (*GetResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method Add not implemented"), 501)
}
func (UnimplementedCounterServer) Get(ctx sdk_go.ObjectSharedContext, req *GetRequest) (*GetResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method Get not implemented"), 501)
}
func (UnimplementedCounterServer) AddWatcher(ctx sdk_go.ObjectContext, req *AddWatcherRequest) (*AddWatcherResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method AddWatcher not implemented"), 501)
}
func (UnimplementedCounterServer) Watch(ctx sdk_go.ObjectSharedContext, req *WatchRequest) (*GetResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method Watch not implemented"), 501)
}
func (UnimplementedCounterServer) testEmbeddedByValue() {}

// UnsafeCounterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CounterServer will
// result in compilation errors.
type UnsafeCounterServer interface {
	mustEmbedUnimplementedCounterServer()
}

func NewCounterServer(srv CounterServer, opts ...sdk_go.ServiceDefinitionOption) sdk_go.ServiceDefinition {
	// If the following call panics, it indicates UnimplementedCounterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	sOpts := append([]sdk_go.ServiceDefinitionOption{sdk_go.WithProtoJSON}, opts...)
	router := sdk_go.NewObject("helloworld.Counter", sOpts...)
	router = router.Handler("Add", sdk_go.NewObjectHandler(srv.Add))
	router = router.Handler("Get", sdk_go.NewObjectSharedHandler(srv.Get))
	router = router.Handler("AddWatcher", sdk_go.NewObjectHandler(srv.AddWatcher))
	router = router.Handler("Watch", sdk_go.NewObjectSharedHandler(srv.Watch))
	return router
}

// WorkflowClient is the client API for helloworld.Workflow service.
type WorkflowClient interface {
	// Execute the workflow
	Run(opts ...sdk_go.ClientOption) sdk_go.Client[*RunRequest, *RunResponse]
	// Unblock the workflow
	Finish(opts ...sdk_go.ClientOption) sdk_go.Client[*FinishRequest, *FinishResponse]
	// Check the current status
	Status(opts ...sdk_go.ClientOption) sdk_go.Client[*StatusRequest, *StatusResponse]
}

type workflowClient struct {
	ctx        sdk_go.Context
	workflowID string
	options    []sdk_go.ClientOption
}

func NewWorkflowClient(ctx sdk_go.Context, workflowID string, opts ...sdk_go.ClientOption) WorkflowClient {
	cOpts := append([]sdk_go.ClientOption{sdk_go.WithProtoJSON}, opts...)
	return &workflowClient{
		ctx,
		workflowID,
		cOpts,
	}
}
func (c *workflowClient) Run(opts ...sdk_go.ClientOption) sdk_go.Client[*RunRequest, *RunResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*RunRequest](sdk_go.Workflow[*RunResponse](c.ctx, "helloworld.Workflow", c.workflowID, "Run", cOpts...))
}

func (c *workflowClient) Finish(opts ...sdk_go.ClientOption) sdk_go.Client[*FinishRequest, *FinishResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*FinishRequest](sdk_go.Workflow[*FinishResponse](c.ctx, "helloworld.Workflow", c.workflowID, "Finish", cOpts...))
}

func (c *workflowClient) Status(opts ...sdk_go.ClientOption) sdk_go.Client[*StatusRequest, *StatusResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*StatusRequest](sdk_go.Workflow[*StatusResponse](c.ctx, "helloworld.Workflow", c.workflowID, "Status", cOpts...))
}

// WorkflowIngressClient is the ingress client API for helloworld.Workflow service.
//
// This client is used to call the service from outside of a Restate context.
type WorkflowIngressClient interface {
	// Execute the workflow
	Submit(input *RunRequest, opts ...sdk_go.IngressSendOption) ingress.Invocation
	// Attach attaches to the submitted workflow and returns a handle to retrieve its output
	Attach() ingress.InvocationHandle[*RunResponse]
	// Unblock the workflow
	Finish() ingress.Requester[*FinishRequest, *FinishResponse]
	// Check the current status
	Status() ingress.Requester[*StatusRequest, *StatusResponse]
}

type workflowIngressClient struct {
	client      *ingress.Client
	serviceName string
	workflowID  string
}

func NewWorkflowIngressClient(client *ingress.Client, workflowID string) WorkflowIngressClient {
	return &workflowIngressClient{
		client,
		"helloworld.Workflow",
		workflowID,
	}
}

func (c *workflowIngressClient) Submit(input *RunRequest, opts ...sdk_go.IngressSendOption) ingress.Invocation {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*RunRequest, *RunResponse](c.client, c.serviceName, "Run", &c.workflowID, &codec).Send(context.Background(), input, opts...)
}

func (c *workflowIngressClient) Finish() ingress.Requester[*FinishRequest, *FinishResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*FinishRequest, *FinishResponse](c.client, c.serviceName, "Finish", &c.workflowID, &codec)
}

func (c *workflowIngressClient) Status() ingress.Requester[*StatusRequest, *StatusResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*StatusRequest, *StatusResponse](c.client, c.serviceName, "Status", &c.workflowID, &codec)
}

func (c *workflowIngressClient) Attach() ingress.InvocationHandle[*RunResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.AttachWorkflowWithCodec[*RunResponse](c.client, c.serviceName, c.workflowID, codec)
}

// WorkflowServer is the server API for helloworld.Workflow service.
// All implementations should embed UnimplementedWorkflowServer
// for forward compatibility.
type WorkflowServer interface {
	// Execute the workflow
	Run(ctx sdk_go.WorkflowContext, req *RunRequest) (*RunResponse, error)
	// Unblock the workflow
	Finish(ctx sdk_go.WorkflowSharedContext, req *FinishRequest) (*FinishResponse, error)
	// Check the current status
	Status(ctx sdk_go.WorkflowSharedContext, req *StatusRequest) (*StatusResponse, error)
}

// UnimplementedWorkflowServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowServer struct{}

func (UnimplementedWorkflowServer) Run(ctx sdk_go.WorkflowContext, req *RunRequest) (*RunResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method Run not implemented"), 501)
}
func (UnimplementedWorkflowServer) Finish(ctx sdk_go.WorkflowSharedContext, req *FinishRequest) (*FinishResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method Finish not implemented"), 501)
}
func (UnimplementedWorkflowServer) Status(ctx sdk_go.WorkflowSharedContext, req *StatusRequest) (*StatusResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method Status not implemented"), 501)
}
func (UnimplementedWorkflowServer) testEmbeddedByValue() {}

// UnsafeWorkflowServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowServer will
// result in compilation errors.
type UnsafeWorkflowServer interface {
	mustEmbedUnimplementedWorkflowServer()
}

func NewWorkflowServer(srv WorkflowServer, opts ...sdk_go.ServiceDefinitionOption) sdk_go.ServiceDefinition {
	// If the following call panics, it indicates UnimplementedWorkflowServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	sOpts := append([]sdk_go.ServiceDefinitionOption{sdk_go.WithProtoJSON}, opts...)
	router := sdk_go.NewWorkflow("helloworld.Workflow", sOpts...)
	router = router.Handler("Run", sdk_go.NewWorkflowHandler(srv.Run))
	router = router.Handler("Finish", sdk_go.NewWorkflowSharedHandler(srv.Finish))
	router = router.Handler("Status", sdk_go.NewWorkflowSharedHandler(srv.Status))
	return router
}
