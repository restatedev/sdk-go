package main

import (
	"fmt"
	"strings"

	"github.com/restatedev/sdk-go/generated/dev/restate/sdk"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	fmtPackage = protogen.GoImportPath("fmt")
	sdkPackage = protogen.GoImportPath("github.com/restatedev/sdk-go")
)

type serviceGenerateHelper struct{}

func generateClientStruct(g *protogen.GeneratedFile, service *protogen.Service, clientName string) {
	g.P("type ", unexport(clientName), " struct {")
	g.P("ctx ", sdkPackage.Ident("Context"))
	serviceType := proto.GetExtension(service.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)
	switch serviceType {
	case sdk.ServiceType_VIRTUAL_OBJECT:
		g.P("key string")
	case sdk.ServiceType_WORKFLOW:
		g.P("workflowID string")
	}
	g.P("options []", sdkPackage.Ident("ClientOption"))
	g.P("}")
}

func generateNewClientDefinitions(g *protogen.GeneratedFile, service *protogen.Service, clientName string) {
	g.P("cOpts := append([]", sdkPackage.Ident("ClientOption"), "{", sdkPackage.Ident("WithProtoJSON"), "}, opts...)")
	g.P("return &", unexport(clientName), "{")
	g.P("ctx,")
	serviceType := proto.GetExtension(service.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)
	switch serviceType {
	case sdk.ServiceType_VIRTUAL_OBJECT:
		g.P("key,")
	case sdk.ServiceType_WORKFLOW:
		g.P("workflowID,")
	}
	g.P("cOpts,")
	g.P("}")
}

func generateUnimplementedServerType(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service) {
	serverType := service.GoName + "Server"
	mustOrShould := "must"
	if !*requireUnimplemented {
		mustOrShould = "should"
	}
	// Server Unimplemented struct for forward compatibility.
	g.P("// Unimplemented", serverType, " ", mustOrShould, " be embedded to have")
	g.P("// forward compatible implementations.")
	g.P("//")
	g.P("// NOTE: this should be embedded by value instead of pointer to avoid a nil")
	g.P("// pointer dereference when methods are called.")
	g.P("type Unimplemented", serverType, " struct {}")
	g.P()
	for _, method := range service.Methods {
		g.P("func (Unimplemented", serverType, ") ", serverSignature(gen, g, method), "{")
		g.P("return ", "nil,", sdkPackage.Ident("TerminalError"), "(", fmtPackage.Ident("Errorf"), `("method `, methodName(method), ` not implemented"), 501)`)
		g.P("}")
	}
	if *requireUnimplemented {
		g.P("func (Unimplemented", serverType, ") mustEmbedUnimplemented", serverType, "() {}")
	}
	g.P("func (Unimplemented", serverType, ") testEmbeddedByValue() {}")
	g.P()
}

// FileDescriptorProto.package field number
const fileDescriptorProtoPackageFieldNumber = 2

// FileDescriptorProto.syntax field number
const fileDescriptorProtoSyntaxFieldNumber = 12

// generateFile generates a _restate.pb.go file containing Restate service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_restate.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	// Attach all comments associated with the syntax field.
	genLeadingComments(g, file.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoSyntaxFieldNumber}))
	g.P("// Code generated by protoc-gen-go-restate. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-restate v", version)
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	// Attach all comments associated with the package field.
	genLeadingComments(g, file.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoPackageFieldNumber}))
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// generateFileContent generates the service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		genService(gen, g, service)
	}
}

// genServiceComments copies the comments from the RPC proto definitions
// to the corresponding generated interface file.
func genServiceComments(g *protogen.GeneratedFile, service *protogen.Service) {
	if service.Comments.Leading != "" {
		// Add empty comment line to attach this service's comments to
		// the godoc comments previously output for all services.
		g.P("//")
		g.P(strings.TrimSpace(service.Comments.Leading.String()))
	}
}

func genService(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service) {
	// Client interface.
	clientName := service.GoName + "Client"

	g.P("// ", clientName, " is the client API for ", serviceName(service), " service.")
	g.P("//")

	// Copy comments from proto file.
	genServiceComments(g, service)

	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	g.AnnotateSymbol(clientName, protogen.Annotation{Location: service.Location})
	g.P("type ", clientName, " interface {")
	for _, method := range service.Methods {
		g.AnnotateSymbol(clientName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.Comments.Leading,
			clientSignature(g, method))
	}
	g.P("}")
	g.P()

	// Client structure.
	generateClientStruct(g, service, clientName)

	// NewClient factory.
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P(deprecationComment)
	}
	newClientSignature := "New" + clientName + " (ctx " + g.QualifiedGoIdent(sdkPackage.Ident("Context"))
	serviceType := proto.GetExtension(service.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)
	switch serviceType {
	case sdk.ServiceType_VIRTUAL_OBJECT:
		newClientSignature += ", key string"
	case sdk.ServiceType_WORKFLOW:
		newClientSignature += ", workflowID string"
	}
	newClientSignature += ", opts..." + g.QualifiedGoIdent(sdkPackage.Ident("ClientOption")) + ") " + clientName

	g.P("func ", newClientSignature, " {")
	generateNewClientDefinitions(g, service, clientName)
	g.P("}")

	var methodIndex int
	// Client method implementations.
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			genClientMethod(gen, g, method)
			methodIndex++
		} else {
			gen.Error(fmt.Errorf("streaming methods are not currently supported in Restate."))
		}
	}

	mustOrShould := "must"
	if !*requireUnimplemented {
		mustOrShould = "should"
	}

	// Server interface.
	serverType := service.GoName + "Server"
	g.P("// ", serverType, " is the server API for ", serviceName(service), " service.")
	g.P("// All implementations ", mustOrShould, " embed Unimplemented", serverType)
	g.P("// for forward compatibility.")

	// Copy comments from proto file.
	genServiceComments(g, service)

	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	g.AnnotateSymbol(serverType, protogen.Annotation{Location: service.Location})
	g.P("type ", serverType, " interface {")
	for _, method := range service.Methods {
		g.AnnotateSymbol(serverType+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.Comments.Leading,
			serverSignature(gen, g, method))
	}
	if *requireUnimplemented {
		g.P("mustEmbedUnimplemented", serverType, "()")
	}
	g.P("}")
	g.P()

	// Server Unimplemented struct for forward compatibility.
	generateUnimplementedServerType(gen, g, service)

	// Unsafe Server interface to opt-out of forward compatibility.
	g.P("// Unsafe", serverType, " may be embedded to opt out of forward compatibility for this service.")
	g.P("// Use of this interface is not recommended, as added methods to ", serverType, " will")
	g.P("// result in compilation errors.")
	g.P("type Unsafe", serverType, " interface {")
	g.P("mustEmbedUnimplemented", serverType, "()")
	g.P("}")

	// Server registration.
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P(deprecationComment)
	}

	g.P("func New", service.GoName, "Server(srv ", serverType, ", opts ...", sdkPackage.Ident("ServiceDefinitionOption"), ") ", sdkPackage.Ident("ServiceDefinition"), " {")
	g.P("// If the following call panics, it indicates Unimplemented", serverType, " was")
	g.P("// embedded by pointer and is nil.  This will cause panics if an")
	g.P("// unimplemented method is ever invoked, so we test this at initialization")
	g.P("// time to prevent it from happening at runtime later due to I/O.")
	g.P("if t, ok := srv.(interface { testEmbeddedByValue() }); ok {")
	g.P("t.testEmbeddedByValue()")
	g.P("}")
	g.P("sOpts := append([]", sdkPackage.Ident("ServiceDefinitionOption"), "{", sdkPackage.Ident("WithProtoJSON"), "}, opts...)")
	g.P("router := ", newRouterType(gen, g, service), `("`, serviceName(service), `", sOpts...)`)
	for _, method := range service.Methods {
		g.P(`router = router.Handler("`, methodName(method), `",`, newHandlerType(gen, g, method), "(srv.", method.GoName, "))")
	}
	g.P("return router")
	g.P("}")
	g.P()
}

func clientSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	s := method.GoName + "("
	s += "opts ..." + g.QualifiedGoIdent(sdkPackage.Ident("ClientOption")) + ") ("
	s += g.QualifiedGoIdent(sdkPackage.Ident("Client")) + "[" + "*" + g.QualifiedGoIdent(method.Input.GoIdent) + ", *" + g.QualifiedGoIdent(method.Output.GoIdent) + "]"
	s += ")"
	return s
}

func genClientMethod(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) {
	service := method.Parent
	serviceType := proto.GetExtension(service.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)

	if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
		g.P(deprecationComment)
	}
	g.P("func (c *", unexport(service.GoName), "Client) ", clientSignature(g, method), "{")

	g.P("cOpts := c.options")
	g.P("if len(opts) > 0 {")
	g.P("cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)")
	g.P("}")
	var getClient string
	switch serviceType {
	case sdk.ServiceType_SERVICE:
		getClient = g.QualifiedGoIdent(sdkPackage.Ident("Service")) + `[*` + g.QualifiedGoIdent(method.Output.GoIdent) + `]` + `(c.ctx, "` + serviceName(service) + `",`
	case sdk.ServiceType_VIRTUAL_OBJECT:
		getClient = g.QualifiedGoIdent(sdkPackage.Ident("Object")) + `[*` + g.QualifiedGoIdent(method.Output.GoIdent) + `]` + `(c.ctx, "` + serviceName(service) + `", c.key,`
	case sdk.ServiceType_WORKFLOW:
		getClient = g.QualifiedGoIdent(sdkPackage.Ident("Workflow")) + `[*` + g.QualifiedGoIdent(method.Output.GoIdent) + `]` + `(c.ctx, "` + serviceName(service) + `", c.workflowID,`
	default:
		gen.Error(fmt.Errorf("Unexpected service type: %s", serviceType.String()))
		return
	}
	getClient += `"` + methodName(method) + `", cOpts...)`
	g.P("return ", sdkPackage.Ident("WithRequestType"), "[*", method.Input.GoIdent, "]", `(`, getClient, `)`)
	g.P("}")
	g.P()
	return
}

func serviceName(service *protogen.Service) string {
	if *useGoServiceNames {
		return service.GoName
	}
	return string(service.Desc.FullName())
}

func methodName(method *protogen.Method) string {
	if *useGoServiceNames {
		return method.GoName
	}
	return string(method.Desc.Name())
}

func serverSignature(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	reqArgs = append(reqArgs, contextType(gen, g, method))
	return method.GoName +
		"(ctx " + contextType(gen, g, method) +
		", req *" + g.QualifiedGoIdent(method.Input.GoIdent) + ") (*" +
		g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
}

func contextType(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) string {
	serviceType := proto.GetExtension(method.Parent.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)
	handlerType := proto.GetExtension(method.Desc.Options().(*descriptorpb.MethodOptions), sdk.E_HandlerType).(sdk.HandlerType)

	switch serviceType {
	case sdk.ServiceType_SERVICE:
		if handlerType != sdk.HandlerType_UNSET {
			gen.Error(fmt.Errorf("Handlers in services of type SERVICE should not have a handler type set"))
			return ""
		}
		return g.QualifiedGoIdent(sdkPackage.Ident("Context"))
	case sdk.ServiceType_VIRTUAL_OBJECT:
		switch handlerType {
		case sdk.HandlerType_SHARED:
			return g.QualifiedGoIdent(sdkPackage.Ident("ObjectSharedContext"))
		case sdk.HandlerType_UNSET, sdk.HandlerType_EXCLUSIVE:
			// unset also defaults to exclusive
			return g.QualifiedGoIdent(sdkPackage.Ident("ObjectContext"))
		default:
			gen.Error(fmt.Errorf("Handlers in services of type VIRTUAL_OBJECT must have type SHARED, EXCLUSIVE, or unset (defaults to EXCLUSIVE)"))
			return ""
		}
	case sdk.ServiceType_WORKFLOW:
		switch handlerType {
		case sdk.HandlerType_SHARED:
			return g.QualifiedGoIdent(sdkPackage.Ident("WorkflowSharedContext"))
		case sdk.HandlerType_WORKFLOW_RUN:
			return g.QualifiedGoIdent(sdkPackage.Ident("WorkflowContext"))
		case sdk.HandlerType_UNSET:
			if method.GoName == "Run" {
				return g.QualifiedGoIdent(sdkPackage.Ident("WorkflowContext"))
			} else {
				return g.QualifiedGoIdent(sdkPackage.Ident("WorkflowSharedContext"))
			}
		default:
			gen.Error(fmt.Errorf("Handlers in services of type WORKFLOW must have type SHARED, WORKFLOW_RUN, or unset (defaults to SHARED unless the method name is 'Run')"))
			return ""
		}
	default:
		gen.Error(fmt.Errorf("Unexpected service type: %s", serviceType.String()))
		return ""
	}
}

func newRouterType(gen *protogen.Plugin, g *protogen.GeneratedFile, service *protogen.Service) string {
	serviceType := proto.GetExtension(service.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)
	switch serviceType {
	case sdk.ServiceType_SERVICE:
		return g.QualifiedGoIdent(sdkPackage.Ident("NewService"))
	case sdk.ServiceType_VIRTUAL_OBJECT:
		return g.QualifiedGoIdent(sdkPackage.Ident("NewObject"))
	case sdk.ServiceType_WORKFLOW:
		return g.QualifiedGoIdent(sdkPackage.Ident("NewWorkflow"))
	default:
		gen.Error(fmt.Errorf("Unexpected service type: %s", serviceType.String()))
		return ""
	}
}

func newHandlerType(gen *protogen.Plugin, g *protogen.GeneratedFile, method *protogen.Method) string {
	serviceType := proto.GetExtension(method.Parent.Desc.Options().(*descriptorpb.ServiceOptions), sdk.E_ServiceType).(sdk.ServiceType)
	handlerType := proto.GetExtension(method.Desc.Options().(*descriptorpb.MethodOptions), sdk.E_HandlerType).(sdk.HandlerType)

	switch serviceType {
	case sdk.ServiceType_SERVICE:
		if handlerType != sdk.HandlerType_UNSET {
			gen.Error(fmt.Errorf("Handlers in services of type SERVICE should not have a handler type set"))
			return ""
		}
		return g.QualifiedGoIdent(sdkPackage.Ident("NewServiceHandler"))
	case sdk.ServiceType_VIRTUAL_OBJECT:
		switch handlerType {
		case sdk.HandlerType_SHARED:
			return g.QualifiedGoIdent(sdkPackage.Ident("NewObjectSharedHandler"))
		case sdk.HandlerType_UNSET, sdk.HandlerType_EXCLUSIVE:
			// unset also defaults to exclusive
			return g.QualifiedGoIdent(sdkPackage.Ident("NewObjectHandler"))
		default:
			gen.Error(fmt.Errorf("Handlers in services of type VIRTUAL_OBJECT must have type SHARED, EXCLUSIVE, or unset (defaults to EXCLUSIVE)"))
			return ""
		}
	case sdk.ServiceType_WORKFLOW:
		switch handlerType {
		case sdk.HandlerType_SHARED:
			return g.QualifiedGoIdent(sdkPackage.Ident("NewWorkflowSharedHandler"))
		case sdk.HandlerType_WORKFLOW_RUN:
			return g.QualifiedGoIdent(sdkPackage.Ident("NewWorkflowHandler"))
		case sdk.HandlerType_UNSET:
			if method.GoName == "Run" {
				return g.QualifiedGoIdent(sdkPackage.Ident("NewWorkflowHandler"))
			} else {
				return g.QualifiedGoIdent(sdkPackage.Ident("NewWorkflowSharedHandler"))
			}
		default:
			gen.Error(fmt.Errorf("Handlers in services of type WORKFLOW must have type SHARED, WORKFLOW_RUN, or unset (defaults to SHARED unless the method name is 'Run')"))
			return ""
		}
	default:
		gen.Error(fmt.Errorf("Unexpected service type: %s", serviceType.String()))
		return ""
	}
}

func genLeadingComments(g *protogen.GeneratedFile, loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}

const deprecationComment = "// Deprecated: Do not use."

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }
